<html>
<body>

<div id="divUi">

	<h3>Sliding-Tile Puzzle</h3>

	<p>
		A sliding-tile puzzle.  Press the arrow keys to move the cursor.
		Press Enter to slide a tile into an adjacent empty space, if any.
		The object is to get all of the tiles in order.
	</p>

</div>

<script type="text/javascript">

// main
 
function main()
{
	var display = new Display
	(
		new Coords(100, 100), // sizeInPixels
		10, // fontHeightInPixels
		"White", // colorBack
		"Gray" // colorFore
	);

	var grid = new Grid
	(
		new Coords(4, 4)
	).randomize();

	Globals.Instance.initialize
	(
		display, grid
	);
}
 
// classes
 
class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	add(other)
	{
		this.x += other.x;
		this.y += other.y;
		return this;
	}

	divide(other)
	{
		this.x /= other.x;
		this.y /= other.y;
		return this;
	}

	divideScalar(scalar)
	{
		this.x /= scalar;
		this.y /= scalar;
		return this;
	}
	 
	clone()
	{
		return new Coords(this.x, this.y);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}
	 
	magnitude()
	{
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	 
	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	subtract(other)
	{
		this.x -= other.x;
		this.y -= other.y;
		return this;
	}

	trimToRangeMax(max)
	{
		if (this.x < 0)
		{
			this.x = 0;
		}
		else if (this.x > max.x)
		{
			this.x = max.x;
		}

		if (this.y < 0)
		{
			this.y = 0;
		}
		else if (this.y > max.y)
		{
			this.y = max.y;
		}

		return this;
	}
}
 
class Display
{
	constructor(sizeInPixels, fontHeightInPixels, colorBack, colorFore)
	{
		this.sizeInPixels = sizeInPixels;
		this.fontHeightInPixels = fontHeightInPixels;
		this.colorBack = colorBack;
		this.colorFore = colorFore;
	}

	initialize()
	{
		var canvas = document.createElement("canvas");
		canvas.width = this.sizeInPixels.x;
		canvas.height = this.sizeInPixels.y;

		this.graphics = canvas.getContext("2d");
		this.graphics.font = this.fontHeightInPixels + "px sans-serif";

		document.body.appendChild(canvas);
	}

	// drawing

	clear()
	{
		this.drawRectangle
		(
			new Coords(0, 0),
			this.sizeInPixels,
			this.colorBack,
			this.colorFore
		);
	}

	drawRectangle(pos, size, colorFill, colorBorder)
	{
		if (colorFill != null)
		{
			this.graphics.fillStyle = colorFill;
			this.graphics.fillRect
			(
				pos.x, pos.y,
				size.x, size.y
			);
		}

		if (colorBorder != null)
		{
			this.graphics.strokeStyle = colorBorder;
			this.graphics.strokeRect
			(
				pos.x, pos.y,
				size.x, size.y
			);
		}
	}

	drawText(text, pos, color)
	{
		this.graphics.fillStyle = color;
		this.graphics.fillText
		(
			text,
			pos.x, pos.y + this.fontHeightInPixels
		);
	}
 
}
 
class Globals
{
	static Instance = new Globals();

	initialize(display, grid)
	{
		this.display = display;
		this.grid = grid;

		this.display.initialize();
		this.grid.drawToDisplay(this.display);

		this.inputHelper = new InputHelper();
		this.inputHelper.initialize();
	}
}

class Grid
{
	constructor(sizeInCells)
	{
		this.sizeInCells = sizeInCells;

		this.cells = [];

		this.cursorPos = new Coords(0, 0);
	}

	cellAtPosGet(cellPos)
	{
		var cellIndex = this.indexOfCellAtPos(cellPos);
		var cellValue = this.cells[cellIndex];
		return cellValue;
	}

	cellAtPosSet(cellPos, valueToSet)
	{
		var cellIndex = this.indexOfCellAtPos(cellPos);
		this.cells[cellIndex] = valueToSet;
	}

	cursorMove(direction)
	{
		this.cursorPos.add
		(
			direction
		).trimToRangeMax
		(
			this.sizeInCells
		);
	}

	indexOfCellAtPos(cellPos)
	{
		return cellPos.y * this.sizeInCells.x + cellPos.x;
	}

	openCellPos()
	{
		var cellPos = new Coords();

		for (var y = 0; y < this.sizeInCells.y; y++)
		{
			cellPos.y = y;
			 
			var cellValue = null;
			 
			for (var x = 0; x < this.sizeInCells.x; x++)
			{
				cellPos.x = x;
				 
				cellValue = this.cellAtPosGet(cellPos);
				 
				if (cellValue == null)
				{
					break;
				}
			}
			 
			if (cellValue == null)
			{
				break;
			}
		}
		 
		return cellPos;
	}

	randomize()
	{
		var numberOfCells = this.sizeInCells.x * this.sizeInCells.y;

		for (var i = 0; i < numberOfCells; i++)
		{
			this.cells[i] = null;
		}

		for (var i = 0; i < numberOfCells - 1; i++)
		{
			var cellIndex = Math.floor
			(
				Math.random() * numberOfCells
			);

			while (this.cells[cellIndex] != null)
			{
				cellIndex++;
				if (cellIndex >= numberOfCells)
				{
					cellIndex = 0;
				}
			}

			this.cells[cellIndex] = i;

		}

		return this;
	}

	slideAtCursorIfPossible()
	{
		var openCellPos = this.openCellPos();
		var displacement = openCellPos.clone().subtract
		(
			this.cursorPos
		);
		var distance = displacement.magnitude();
		if (distance == 1)
		{
			var cellValueToSlide = this.cellAtPosGet(this.cursorPos);
			this.cellAtPosSet(this.cursorPos, null);
			this.cellAtPosSet(openCellPos, cellValueToSlide);
		}
	}
	 
	// drawable
	 
	drawToDisplay(display)
	{
		var cellSizeInPixels =
		display.sizeInPixels.clone().divide
		(
			this.sizeInCells
		);

		var cellSizeInPixelsHalf =
		cellSizeInPixels.clone().divideScalar(2);

		var cellPos = new Coords();
		var drawPos = new Coords();
		var cellInde;
		var cellValue;

		for (var y = 0; y < this.sizeInCells.y; y++)
		{
			cellPos.y = y;

			for (var x = 0; x < this.sizeInCells.x; x++)
			{
				cellPos.x = x;

				cellValue = this.cellAtPosGet(cellPos);
				if (cellValue == null)
				{
					cellValue = "";
				}

				drawPos.overwriteWith
				(
					cellPos
				).multiply
				(
					cellSizeInPixels
				);
				 
				display.drawRectangle
				(
					drawPos,
					cellSizeInPixels,
					display.colorBack, // fill
					display.colorFore // border
				);
				 
				drawPos.add
				(
					cellSizeInPixelsHalf
				);
				 
				display.drawText
				(
					"" + cellValue,
					drawPos,
					display.colorFore
				);
			}
		}

		drawPos.overwriteWith
		(
			this.cursorPos
		).multiply
		(
			cellSizeInPixels
		);

		display.drawRectangle
		(
			drawPos,
			cellSizeInPixels,
			display.colorFore, // fill
			display.colorBack // border
		);

		drawPos.add
		(
			cellSizeInPixelsHalf
		);

		cellValue = this.cellAtPosGet(this.cursorPos);
		if (cellValue == null)
		{
			cellValue = "";
		}

		display.drawText
		(
			"" + cellValue,
			drawPos,
			display.colorBack
		);
	}
}

class InputHelper
{
	initialize()
	{
		document.body.onkeydown = this.handleEventKeyDown.bind(this);
	}

	// events

	handleEventKeyDown(event)
	{
		var keyPressed = event.key;

		var grid = Globals.Instance.grid;

		if (keyPressed == "ArrowDown")
		{
			grid.cursorMove(new Coords(0, 1));
		}
		else if (keyPressed == "ArrowLeft")
		{
			grid.cursorMove(new Coords(-1, 0));
		}
		else if (keyPressed == "ArrowRight")
		{
			grid.cursorMove(new Coords(1, 0));
		}
		else if (keyPressed == "ArrowUp")
		{
			grid.cursorMove(new Coords(0, -1));
		}
		else if (keyPressed == "Enter")
		{
			grid.slideAtCursorIfPossible();
		}

		grid.drawToDisplay(Globals.Instance.display);

	}
}

// run

main();

</script>
</body>
</html>